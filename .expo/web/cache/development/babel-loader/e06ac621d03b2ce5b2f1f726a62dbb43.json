{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _core = require(\"@unimodules/core\");\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _StyleSheet = _interopRequireDefault(require(\"react-native-web/dist/exports/StyleSheet\"));\n\nvar _View = _interopRequireDefault(require(\"react-native-web/dist/exports/View\"));\n\nvar _createElement = _interopRequireDefault(require(\"react-native-web/dist/exports/createElement\"));\n\nvar _Camera = require(\"./Camera.types\");\n\nvar _ExponentCameraManager = _interopRequireDefault(require(\"./ExponentCameraManager.web\"));\n\nvar _WebCameraUtils = require(\"./WebCameraUtils\");\n\nvar _WebConstants = require(\"./WebConstants\");\n\nvar _useWebCameraStream = require(\"./useWebCameraStream\");\n\nvar _useWebQRScanner = require(\"./useWebQRScanner\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar ExponentCamera = React.forwardRef(function (_ref, ref) {\n  var _props$barCodeScanner3, _props$barCodeScanner4;\n\n  var type = _ref.type,\n      pictureSize = _ref.pictureSize,\n      poster = _ref.poster,\n      props = (0, _objectWithoutProperties2.default)(_ref, [\"type\", \"pictureSize\", \"poster\"]);\n  var video = React.useRef(null);\n  var native = (0, _useWebCameraStream.useWebCameraStream)(video, type, props, {\n    onCameraReady: function onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  var isQRScannerEnabled = React.useMemo(function () {\n    var _props$barCodeScanner, _props$barCodeScanner2;\n\n    return !!((_props$barCodeScanner = props.barCodeScannerSettings) != null && (_props$barCodeScanner2 = _props$barCodeScanner.barCodeTypes) != null && _props$barCodeScanner2.includes('qr') && !!props.onBarCodeScanned);\n  }, [(_props$barCodeScanner3 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner3.barCodeTypes, props.onBarCodeScanned]);\n  (0, _useWebQRScanner.useWebQRScanner)(video, {\n    interval: (_props$barCodeScanner4 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner4.interval,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === _Camera.CameraType.front\n    },\n    onScanned: function onScanned(event) {\n      if (props.onBarCodeScanned) {\n        props.onBarCodeScanned(event);\n      }\n    }\n  });\n  React.useImperativeHandle(ref, function () {\n    return {\n      getAvailablePictureSizes: function getAvailablePictureSizes(ratio) {\n        return _regenerator.default.async(function getAvailablePictureSizes$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", _WebConstants.PictureSizes);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      },\n      takePicture: function takePicture(options) {\n        var _video$current, _video$current2;\n\n        var settings;\n        return _regenerator.default.async(function takePicture$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(!video.current || ((_video$current = video.current) == null ? void 0 : _video$current.readyState) !== ((_video$current2 = video.current) == null ? void 0 : _video$current2.HAVE_ENOUGH_DATA))) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new _core.CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n\n              case 2:\n                settings = native.mediaTrackSettings;\n\n                if (settings) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new _core.CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n\n              case 5:\n                return _context2.abrupt(\"return\", (0, _WebCameraUtils.capture)(video.current, settings, _objectSpread(_objectSpread({}, options), {}, {\n                  onPictureSaved: function onPictureSaved(picture) {\n                    if (options.onPictureSaved) {\n                      options.onPictureSaved(picture);\n                    }\n\n                    if (props.onPictureSaved) {\n                      props.onPictureSaved({\n                        nativeEvent: {\n                          data: picture,\n                          id: -1\n                        }\n                      });\n                    }\n                  }\n                })));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      },\n      resumePreview: function resumePreview() {\n        return _regenerator.default.async(function resumePreview$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (video.current) {\n                  video.current.play();\n                }\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      },\n      pausePreview: function pausePreview() {\n        return _regenerator.default.async(function pausePreview$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (video.current) {\n                  video.current.pause();\n                }\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }\n    };\n  }, [native.mediaTrackSettings, props.onPictureSaved]);\n  var isMuted = true;\n  var style = React.useMemo(function () {\n    var isFrontFacingCamera = native.type === _ExponentCameraManager.default.Type.front;\n    return [_StyleSheet.default.absoluteFill, styles.video, {\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return React.createElement(_View.default, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style]\n  }, React.createElement(Video, {\n    autoPlay: true,\n    playsInline: true,\n    muted: isMuted,\n    poster: poster,\n    pointerEvents: props.pointerEvents,\n    ref: video,\n    style: style\n  }), props.children);\n});\nvar _default = ExponentCamera;\nexports.default = _default;\nvar Video = React.forwardRef(function (props, ref) {\n  return (0, _createElement.default)('video', _objectSpread(_objectSpread({}, props), {}, {\n    ref: ref\n  }));\n});\n\nvar styles = _StyleSheet.default.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"sources":["../src/ExponentCamera.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\nimport * as React from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = React.forwardRef(\n  (\n    { type, pictureSize, poster, ...props }: CameraNativeProps & { children?: React.ReactNode },\n    ref: React.Ref<ExponentCameraRef>\n  ) => {\n    const video = React.useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, type as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = React.useMemo<boolean>(() => {\n      return !!(\n        props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned\n      );\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: props.barCodeScannerSettings?.interval,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n      onScanned(event) {\n        if (props.onBarCodeScanned) {\n          props.onBarCodeScanned(event);\n        }\n      },\n      // onError: props.onMountError,\n    });\n\n    // const [pause, setPaused]\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(ratio: string): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = React.useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          // webkitPlaysinline\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = React.forwardRef(\n  (\n    props: React.ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: React.Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}