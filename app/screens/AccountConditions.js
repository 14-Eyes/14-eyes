/**
 * Displays a list of health conditions associated with the current user and allows adding or removing items.
 *
 * Conditions are stored locally using a key based on the user's ID. 
 * Users can select new conditions from a picker, and swipe left on existing ones to delete them. 
 * The list includes optional images and descriptions.
 *
 * Generated by Copilot AI
 */


import React, { useState, useEffect, useContext } from "react";
import { FlatList, StyleSheet, View } from "react-native";
import { doc, updateDoc, arrayUnion, arrayRemove, getDoc} from "firebase/firestore";
import { db } from "../config/firebase";
import AuthContext from "../auth/context";
import AppPicker from "../components/AppPicker";
import AppText from "../components/AppText";

import {
  ListItem,
  ListItemDeleteAction,
  ListItemSeparator,
} from "../components/lists/index";
import ScreenFlexible from "../components/ScreenFlexible";
import colors from "../config/colors";
//import choices from "../config/options";
import sstore from "../utility/sstore";
import { fetchCond } from "../utility/fetchOptions";

let initialItems = [];

//const conditionChoices = choices.conditionChoices;

function AccountConditions(props) {
  const authContext = useContext(AuthContext);
  const key = authContext.user.uid + "conditions"; //use user id to create unique id for async storage
  
  const [conditions, setConditions] = useState(initialItems);
  const [conditionChoices, setConditionChoices] = useState([]);
  const [loading, setLoading] = useState(true);

  /* use effect runs only once each time page is rendered */
  useEffect(() => {
    loadData();
  }, []);

  //load conditions and user data
  const loadData = async () => {
    try {
      setLoading(true);

      //fetch conditions from firestore
      const choices = await fetchCond();
      setConditionChoices(choices);

      //fetch user information
      const userDocRef = doc(db, "users", authContext.user.uid);
      const userDoc = await getDoc(userDocRef);

      if (userDoc.exists()) {
        const data = userDoc.data();
        const conditionIDs = data.conditions || [];

        const fullConditions = conditionIDs
          .map(id => choices.find(choice => choice.id === id))
          .filter(condition => condition !== undefined);

        setConditions(fullConditions);
        sstore.store(key, fullConditions);
      }
    } catch (error) {
      console.error("Firestore condition loading error:", error);

      const response = await sstore.get(key);
      setConditions(response || []);
    } finally {
      setLoading(false);
    }
    //const response = await sstore.get(key);
    //setConditions(response);
  };

  //delete conditios from user account
  const handleDelete = async (condition) => {
    try{
      
      const updated = conditions.filter((m) => m.id !== condition.id);
      setConditions(updated);

      const userDocRef = doc(db, "users", authContext.user.uid);
      await updateDoc(userDocRef, {
        conditions: arrayRemove(condition.id)
      });
      
      sstore.store(key, updated);
      console.log("Removed condition");

    } catch (error) {
      console.error("Error with condition removal:", error);
      loadData();    
    }
  };

  //selecting a condition
  const onSelectItem = async (condition) => {
    if (conditions.find(c => c.id === condition.id)) {
      console.log("Condition already added");
      return;
    } 
    try {
      const updated = [...conditions, condition];
      setConditions(updated);
      
      const userDocRef = doc(db, "users", authContext.user.uid);
      await updateDoc(userDocRef, {
        conditions: arrayUnion(condition.id)
      });
      //updated.push(condition);
      //console.log(updated);
      //(updated);
      sstore.store(key, updated);
      console.log("Added Condition");

    } catch (error) {
      console.error("Error adding condition", error);
      loadData();
    }
  };

  return (
    <ScreenFlexible style={styles.screen}>
      {/* Layout wrapper to position tooltip outside scroll area */}
      <View style={styles.container}>
        <View style={styles.listWrapper}>
          <AppPicker
            placeholder="Add Condition"
            items={conditionChoices}
            onSelectItem={onSelectItem}
          />

          <FlatList
            data={conditions}
            keyExtractor={(condition) => condition.id.toString()}
            renderItem={({ item }) => (
              <ListItem
                title={item.label}
                subTitle={item.description}
                titleStyle={{ paddingLeft: 0 }}
                image={item.image}
                renderRightActions={() => (
                  <ListItemDeleteAction onPress={() => handleDelete(item)} />
                )}
                swipeable
                showChevron={false} 
              />
            )}
            ItemSeparatorComponent={ListItemSeparator}
            contentContainerStyle={styles.listContent}
          />
        </View>

        {/* Tooltip BELOW the list (not overlapping) */}
        <View style={styles.toolTipContainer}>
          <AppText style={styles.toolTipText}>Swipe left to remove conditions</AppText>
        </View>
      </View>
    </ScreenFlexible>
  );
}

const TOOLTIP_HEIGHT = 90;

const styles = StyleSheet.create({
  screen: {
    backgroundColor: colors.light,
    flex: 1,
  },
  container: {
    flex: 1,
    paddingTop: 0, // moves top of the list lower on screen
  },
  listWrapper: {
    flex: 1,
    marginBottom: TOOLTIP_HEIGHT, // reserve space for tooltip
  },
  listContent: {
    // paddingBottom: 45, // adds padding at the end of the list
  },
  toolTipContainer: {
    height: TOOLTIP_HEIGHT,
    bottom: "15%", // can also do "bottom: 100" - space between bottom of toolTip and bottom of screen
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: colors.light,
    // borderTopWidth: StyleSheet.hairlineWidth,
    borderColor: colors.medium,
  },
  toolTipText: {
    color: colors.primary,
    fontSize: 22,
  },
});

export default AccountConditions;